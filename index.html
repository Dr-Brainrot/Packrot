<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Italian Brainrot TCG: La Sfida</title>
    
    <style>
/* --- CSS f√ºr das Design --- */
body {
    background-color: #f0f2f5; 
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
}
.brainrot-game {
    padding: 25px;
    max-width: 600px;
    width: 90%; 
    margin: 20px auto;
    border: 3px solid #d32f2f; 
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    font-family: 'Arial', sans-serif;
    position: relative; 
    overflow: hidden; 
}
.brainrot-game h2 {
    color: #d32f2f;
    text-align: center;
    border-bottom: 2px solid #ccc;
    padding-bottom: 10px;
    margin-top: 0;
}
.coin-display {
    font-size: 26px;
    font-weight: bold;
    color: #ffc107; 
    text-shadow: 1px 1px 1px #333;
    text-align: center;
    margin-bottom: 20px;
}
.fight-button, .pack-button, .synth-button {
    width: 100%;
    padding: 12px;
    margin-bottom: 10px;
    border: none;
    border-radius: 6px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
}
.fight-button {
    background-color: #d32f2f; 
    color: white;
}
.fight-button:hover {
    background-color: #c62828;
}
.pack-button {
    background-color: #1976d2; 
    color: white;
}
.pack-button:hover {
    background-color: #1565c0;
}
.synth-button {
    background-color: #FF9800; /* Orange f√ºr Synth */
    color: white;
}
.synth-button:hover {
    background-color: #FB8C00;
}

/* Button zittern bei Fehler */
@keyframes shake-animation {
    0%, 100% { transform: translateX(0); background-color: #1976d2; }
    20%, 60% { transform: translateX(-5px); background-color: #FF5722; }
    40%, 80% { transform: translateX(5px); background-color: #FF5722; }
}
.shake-button {
    animation: shake-animation 0.4s ease-in-out;
}

#char-select {
    width: 100%;
    padding: 10px;
    margin-bottom: 15px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 15px;
}
#game-messages {
    padding: 15px;
    background-color: #e0f7fa;
    border: 1px solid #b2ebf2;
    border-radius: 4px;
    margin-top: 15px;
    min-height: 50px;
    white-space: pre-wrap;
}
/* NEU: Sammlung als Flexbox f√ºr Synth-UI */
#collection-list {
    padding-left: 0;
}
.card-list-item {
    list-style-type: none;
    padding: 5px 0;
    border-bottom: 1px dashed #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.card-list-item strong {
    flex-grow: 1;
}
.card-list-item button {
    margin-left: 10px;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
}
.select-main {
    background-color: #4CAF50;
    color: white;
}
.select-sacrifice {
    background-color: #F44336;
    color: white;
}

/* --- KAMPF VISUALISIERUNG (Unver√§ndert) --- */
.fight-container { display: flex; justify-content: space-around; align-items: flex-start; margin: 20px 0; text-align: center; }
.fighter-panel { width: 45%; background-color: #eee; padding: 10px; border-radius: 8px; min-height: 250px; position: relative; }
.char-img { width: 100%; max-width: 120px; height: auto; border: 3px solid #333; border-radius: 4px; margin-bottom: 5px; }
.vs-text { font-size: 24px; font-weight: bold; color: #d32f2f; line-height: 150px; }
.fighter-stats-info { font-weight: bold; min-height: 30px; margin: 5px 0 0 0; }
.stats-text { margin-top: 5px; }
.hp-bar-container { width: 100%; height: 15px; background-color: #f44336; border-radius: 7px; margin-top: 5px; overflow: hidden; }
.hp-bar-fill { height: 100%; width: 100%; background-color: #4CAF50; transition: width 0.5s ease-out; }
.low-hp { background-color: #f44336; }
.damage-popup { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); color: red; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 3px black; opacity: 0; animation: floatup 1s forwards; pointer-events: none; }
.damage-popup.crit { color: #ffc107; font-size: 30px; }
@keyframes floatup { 0% { opacity: 1; transform: translate(-50%, 0); } 100% { opacity: 0; transform: translate(-50%, -50px); } }

/* --- PACK-√ñFFNUNGS-ANIMATION (Unver√§ndert) --- */
#pack-opening-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease-in-out; }
#pack-opening-overlay.active { opacity: 1; visibility: visible; }
.card-reveal-container { perspective: 1000px; width: 180px; height: 250px; position: relative; cursor: pointer; }
.card-front, .card-back { width: 100%; height: 100%; position: absolute; backface-visibility: hidden; border-radius: 8px; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5); transition: transform 0.8s ease-in-out; background-size: cover; background-position: center; }
.card-front { background-image: url('https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/card_back.png'); transform: rotateY(0deg); }
.card-back { background-image: url('https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760651693496.jpg'); transform: rotateY(180deg); display: flex; flex-direction: column; justify-content: flex-end; align-items: center; color: white; text-shadow: 1px 1px 3px black; padding: 10px; box-sizing: border-box; font-size: 14px; text-align: center; font-weight: bold; }
.card-reveal-container.revealed .card-front { transform: rotateY(-180deg); }
.card-reveal-container.revealed .card-back { transform: rotateY(0deg); }
#revealed-card-info { position: absolute; bottom: 10px; width: 100%; text-align: center; padding: 0 5px; box-sizing: border-box; background-color: rgba(0,0,0,0.4); border-radius: 0 0 8px 8px; padding-top: 5px; padding-bottom: 5px; }
    </style>
</head>
<body>

<div class="brainrot-game">
    <h2>Italian Brainrot TCG: La Sfida ü§å</h2>
    
    <div id="coin-display" class="coin-display">M√ºnzen: 0</div>
    
    <h3>W√§hle deinen K√§mpfer:</h3>
    <select id="char-select"></select>
    
    <button class="fight-button" id="start-battle-button" onclick="handleFightClick()">‚öîÔ∏è Starte Kampf</button>
    <button class="pack-button" id="open-pack-button" onclick="handlePackClick()">üéÅ Pack √∂ffnen (3 M√ºnzen)</button>
    
    <hr>

    <h3>Letzter Kampf:</h3>
    <div id="fight-visuals" class="fight-container">
        <div class="fighter-panel" id="player-fighter">
            <img id="player-img" src="[URL_ZU_EINEM_STANDARD_BILD]" alt="Dein K√§mpfer" class="char-img">
            <div class="fighter-stats-info">
                <p id="player-stats" class="stats-text">W√§hle deinen K√§mpfer</p>
                <div class="hp-bar-container">
                    <div id="player-hp-fill" class="hp-bar-fill"></div>
                </div>
            </div>
        </div>
        <div class="vs-text">VS</div>
        <div class="fighter-panel" id="opponent-fighter">
             <img id="opponent-img" src="[URL_ZU_EINEM_STANDARD_BILD]" alt="Gegner" class="char-img">
            <div class="fighter-stats-info">
                <p id="opponent-stats" class="stats-text">Gegner wartet</p>
                <div class="hp-bar-container">
                    <div id="opponent-hp-fill" class="hp-bar-fill"></div>
                </div>
            </div>
        </div>
    </div>
    
    <h3>Nachrichten:</h3>
    <div id="game-messages">Willkommen in Italien! W√§hle deinen Brainrot!</div>
    
    <hr>
    
    <h3>Fusions-System (Synth)</h3>
    <p>W√§hle eine **Hauptkarte** (gr√ºn) und eine **Opferkarte** (rot) des gleichen Charakters aus der Sammlung, um die Hauptkarte zu leveln.</p>
    <div style="text-align: center; margin-bottom: 10px;">
        <span id="synth-status">Bereit zum Synthetisieren.</span>
    </div>
    <div style="display: flex; justify-content: space-around; margin-bottom: 15px;">
        <span id="synth-main-card">Hauptkarte: Keine</span>
        <span id="synth-sacrifice-card">Opferkarte: Keine</span>
    </div>
    <button class="synth-button" id="start-synth-button" onclick="handleSynthClick()" disabled>üî• Jetzt fusionieren!</button>

    <hr>
    
    <h3>Deine Sammlung:</h3>
    <ul id="collection-list"></ul>

    
    <div id="pack-opening-overlay">
        <div class="card-reveal-container" id="card-reveal-container">
            <div class="card-front"></div>
            <div class="card-back" id="revealed-card-image">
                <div id="revealed-card-info"></div>
            </div>
        </div>
    </div>
</div>

<script>
// --- START DES JAVASCRIPT CODES ---

// 1. SPIELDATEN
const CHARACTER_POOL = [
    { name: "Gert", atk: 50, luck: 70, rarity: "Legend√§r", weight: 2 },
    { name: "Ciro", atk: 80, luck: 30, rarity: "Episch", weight: 5 },
    { name: "Pino", atk: 65, luck: 55, rarity: "Selten", weight: 10 },
    { name: "Maria", atk: 40, luck: 80, rarity: "Selten", weight: 10 },
    { name: "Il Baffo", atk: 75, luck: 45, rarity: "Ungew√∂hnlich", weight: 15 },
    { name: "La Nonna", atk: 35, luck: 90, rarity: "Ungew√∂hnlich", weight: 15 },
    { name: "Luca", atk: 50, luck: 60, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Giulia", atk: 45, luck: 65, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Franco", atk: 60, luck: 50, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Silvia", atk: 30, luck: 70, rarity: "Gew√∂hnlich", weight: 20 },
];

// --- BILDER DATENSTRUKTUR ---
const IMAGE_MAP = {
    "Gert": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603658844.jpg", 
    "Ciro": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603775510.jpg",
    "Pino": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604336272.jpg", 
    "Maria": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603976186.jpg",
    "Il Baffo": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603873171.jpg", 
    "La Nonna": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604469456.jpg",
    "Luca": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604194583.jpg",
    "Giulia": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604449953.jpg",
    "Franco": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604049720.jpg",
    "Silvia": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604414423.jpg",
    "Standard": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760651693496.jpg",
    "CardBack": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/card_back.png" 
};

// --- GLOBALE ZUSTANDSVARIABLEN ---
// NEU: Collection ist jetzt ein Array von Kartenobjekten
let collection = JSON.parse(localStorage.getItem('brainrotCollection')) || [
    { id: 1, name: "Luca", level: 1, xp: 0 },
    { id: 2, name: "Franco", level: 1, xp: 0 },
    { id: 3, name: "Pino", level: 1, xp: 0 }
];
let coins = parseInt(localStorage.getItem('brainrotCoins')) || 0; 
let nextCardId = parseInt(localStorage.getItem('brainrotNextCardId')) || 4; // Z√§hler f√ºr neue Karten-IDs

let isBattling = false;     
let selectedCard = null;  // Beinhaltet jetzt das volle Kartenobjekt aus der collection
let opponentCard = null;  

// Synth-State
let synthMainCardId = null;
let synthSacrificeCardId = null;


const DRAW_WEIGHTS = CHARACTER_POOL.flatMap(char => 
    Array(char.weight).fill(char)
);
const XP_PER_LEVEL = 100; // XP ben√∂tigt f√ºr das n√§chste Level
const XP_PER_WIN = 30;    // XP erhalten pro gewonnenem Kampf


// 2. SPIELLOGIK (Kernfunktionen)

// Hilfsfunktion f√ºr die rundenbasierte Logik (Delay)
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));


// NEUE FUNKTION: Basiswerte der Karte abrufen
function getCharacterBaseStats(name) {
    return CHARACTER_POOL.find(c => c.name === name);
}

// NEUE FUNKTION: Aktuelle Werte basierend auf Level berechnen
function getCharacterCurrentStats(card) {
    const baseStats = getCharacterBaseStats(card.name);
    if (!baseStats) return null;

    // Berechnung des Bonus: Pro Level 5% der Basis-ATK und 2% der Basis-LUCK
    const levelBonus = card.level - 1;
    const atkBonus = Math.round(baseStats.atk * 0.05 * levelBonus);
    const luckBonus = Math.round(baseStats.luck * 0.02 * levelBonus);
    
    return {
        name: card.name,
        atk: baseStats.atk + atkBonus,
        luck: Math.min(100, baseStats.luck + luckBonus), // Luck max. 100
        rarity: baseStats.rarity,
        level: card.level,
        xp: card.xp
    };
}

// NEUE FUNKTION: XP erhalten und Level-Up pr√ºfen
function gainXP(cardId, xp) {
    const card = collection.find(c => c.id === cardId);
    if (!card) return;

    card.xp += xp;
    
    let leveledUp = false;
    while (card.xp >= XP_PER_LEVEL * card.level && card.level < 10) { // Max Level 10
        card.xp -= XP_PER_LEVEL * card.level; // XP f√ºr das aktuelle Level abziehen
        card.level += 1;
        leveledUp = true;
    }
    
    if (leveledUp) {
        document.getElementById('game-messages').innerHTML += `<br>üéâ **${card.name}** ist auf Level **${card.level}** aufgestiegen!`;
        const newStats = getCharacterCurrentStats(card);
        document.getElementById('game-messages').innerHTML += `<br>Neue ATK: ${newStats.atk}, Neue LUCK: ${newStats.luck}%`;
    }
    saveGame();
}

// NEUE FUNKTION: Fusions-Logik
function synthCharacter(mainCardId, sacrificeCardId) {
    const mainCard = collection.find(c => c.id === mainCardId);
    const sacrificeCardIndex = collection.findIndex(c => c.id === sacrificeCardId);

    if (!mainCard || sacrificeCardIndex === -1) {
        return "FEHLER: Karten nicht gefunden.";
    }
    if (mainCard.name !== collection[sacrificeCardIndex].name) {
        return "FEHLER: Karten m√ºssen vom gleichen Charakter sein.";
    }
    if (mainCard.level >= 10) {
         return "FEHLER: Diese Karte hat bereits das maximale Level (10) erreicht.";
    }

    // Die Opferkarte gibt XP basierend auf ihrer Seltenheit (vereinfacht)
    // Gew√∂hnlich: 50 XP, Ungew√∂hnlich: 100 XP, Selten: 150 XP, Episch: 200 XP, Legend√§r: 300 XP
    const rarity = getCharacterBaseStats(mainCard.name).rarity;
    let baseXP = 50;
    if (rarity === "Ungew√∂hnlich") baseXP = 100;
    else if (rarity === "Selten") baseXP = 150;
    else if (rarity === "Episch") baseXP = 200;
    else if (rarity === "Legend√§r") baseXP = 300;
    
    const xpGained = baseXP;

    // 1. Opferkarte aus der Sammlung entfernen
    collection.splice(sacrificeCardIndex, 1);
    
    // 2. Hauptkarte erh√§lt XP (pr√ºft auf Level-Up)
    const oldLevel = mainCard.level;
    mainCard.xp += xpGained;

    // Level-Up-Logik pr√ºfen
    let levelUps = 0;
    while (mainCard.xp >= XP_PER_LEVEL * mainCard.level && mainCard.level < 10) { 
        mainCard.xp -= XP_PER_LEVEL * mainCard.level; 
        mainCard.level += 1;
        levelUps++;
    }
    
    // 3. Status zur√ºcksetzen und speichern
    synthMainCardId = null;
    synthSacrificeCardId = null;
    saveGame();

    const newStats = getCharacterCurrentStats(mainCard);
    
    let message = `üî• **${mainCard.name}** fusioniert! Erhielt ${xpGained} XP. (XP: ${mainCard.xp}/${XP_PER_LEVEL * mainCard.level})`;
    if (levelUps > 0) {
        message += `<br>üéâ AUFSTIEG auf Level **${mainCard.level}**! Neue ATK: ${newStats.atk}, LUCK: ${newStats.luck}%`;
    }
    return message;
}


function drawCard() {
    const baseCard = DRAW_WEIGHTS[Math.floor(Math.random() * DRAW_WEIGHTS.length)];
    // NEU: Neue Karten erhalten Startwerte
    const newCard = {
        id: nextCardId++,
        name: baseCard.name,
        level: 1,
        xp: 0
    };
    return newCard;
}

// === ASYNCHRONE BATTLE-FUNKTION (Aktualisiert f√ºr Level-System) ===
async function battle() {
    // SelectedCard ist nun das Kartenobjekt aus der Collection
    if (isBattling || !selectedCard || !opponentCard) return;

    isBattling = true; 
    
    let playerHP = 100;
    let opponentHP = 100;
    
    document.getElementById('start-battle-button').disabled = true;
    document.getElementById('open-pack-button').disabled = true;

    // Aktuelle Kampf-Werte des Spielers basierend auf Level
    const playerStats = getCharacterCurrentStats(selectedCard);
    
    // KAMPF VISUALISIERUNG START
    document.getElementById('player-img').src = IMAGE_MAP[selectedCard.name] || IMAGE_MAP["Standard"];
    document.getElementById('opponent-img').src = IMAGE_MAP[opponentCard.name] || IMAGE_MAP["Standard"];
    
    document.getElementById('player-fighter').style.border = '';
    document.getElementById('opponent-fighter').style.border = '';
    
    // Initiales HP-Update mit Level-Anzeige
    document.getElementById('player-stats').innerHTML = `**${playerStats.name}** (Lv. ${playerStats.level})<br>ATK: ${playerStats.atk}, LUCK: ${playerStats.luck}%<br>HP: ${playerHP}`;
    document.getElementById('opponent-stats').innerHTML = `**${opponentCard.name}**<br>ATK: ${opponentCard.atk}, LUCK: ${opponentCard.luck}%<br>HP: ${opponentHP}`;
    updateHPBar('player-hp-fill', playerHP);
    updateHPBar('opponent-hp-fill', opponentHP);


    document.getElementById('game-messages').innerHTML = `<h2 class="battle-title">‚öîÔ∏è KAMPF STARTET! ${playerStats.name} (Lv. ${playerStats.level}) vs. ${opponentCard.name} ‚öîÔ∏è</h2>`;

    
    // --- HAUPTSCHLEIFE F√úR DEN RUNDENBASIERTEN KAMPF ---
    while (playerHP > 0 && opponentHP > 0) {
        
        // --- 1. RUNDE: SPIELER-ANGRIFF ---
        
        await animateAttack('player-fighter', 'opponent-fighter');
        
        let playerStrength = calculateStrength(playerStats); // Nutzt Level-Werte
        let playerDamage = Math.max(1, Math.round(playerStrength / 10)); 
        let isPlayerCrit = false;
        
        let critMessage = "";
        if (playerStrength > playerStats.atk) { 
            playerDamage = Math.round(playerDamage * 1.5); 
            critMessage = "‚≠ê Kritischer Gl√ºckstreffer!";
            isPlayerCrit = true;
        }
        
        opponentHP -= playerDamage;
        opponentHP = Math.max(0, opponentHP);

        showDamagePopup('opponent-fighter', playerDamage, isPlayerCrit);
        
        document.getElementById('game-messages').innerHTML += `<p>üí• ${playerStats.name} greift an! Verursacht ${playerDamage} Schaden. ${critMessage}</p>`;
        
        document.getElementById('opponent-stats').innerHTML = `**${opponentCard.name}**<br>ATK: ${opponentCard.atk}, LUCK: ${opponentCard.luck}%<br>HP: ${opponentHP}`;
        updateHPBar('opponent-hp-fill', opponentHP);
        
        if (opponentHP <= 0) break;

        // --- 2. RUNDE: GEGNER-ANGRIFF ---
        await delay(1000); 
        
        await animateAttack('opponent-fighter', 'player-fighter');

        let opponentStrength = calculateStrength(opponentCard);
        let opponentDamage = Math.max(1, Math.round(opponentStrength / 10));
        let isOpponentCrit = false;
        
        let opponentCritMessage = "";
        if (opponentStrength > opponentCard.atk) {
            opponentDamage = Math.round(opponentDamage * 1.5);
            opponentCritMessage = "‚≠ê Kritischer Gl√ºckstreffer!";
            isOpponentCrit = true;
        }
        
        playerHP -= opponentDamage;
        playerHP = Math.max(0, playerHP);
        
        showDamagePopup('player-fighter', opponentDamage, isOpponentCrit);

        document.getElementById('game-messages').innerHTML += `<p>üíî ${opponentCard.name} schl√§gt zur√ºck! Erleidet ${opponentDamage} Schaden. ${opponentCritMessage}</p>`;

        document.getElementById('player-stats').innerHTML = `**${playerStats.name}** (Lv. ${playerStats.level})<br>ATK: ${playerStats.atk}, LUCK: ${playerStats.luck}%<br>HP: ${playerHP}`;
        updateHPBar('player-hp-fill', playerHP);
    }

    // --- KAMPF ENDE & ERGEBNIS ---
    isBattling = false; 
    document.getElementById('start-battle-button').disabled = false; 
    document.getElementById('open-pack-button').disabled = false; 
    
    await delay(2000); 

    let finalMessage = "";
    if (playerHP > 0) {
        coins += 1;
        gainXP(selectedCard.id, XP_PER_WIN); // NEU: XP f√ºr den Spielercharakter
        finalMessage = `üèÜ **SIEG!** Du hast gewonnen, 1 Coin und ${XP_PER_WIN} XP erhalten!`;
        document.getElementById('player-fighter').style.border = '3px solid #4CAF50';
        document.getElementById('opponent-fighter').style.border = '3px solid #F44336';
    } else {
        finalMessage = `üòî **NIEDERLAGE!** Du hast verloren.`;
        document.getElementById('player-fighter').style.border = '3px solid #F44336';
        document.getElementById('opponent-fighter').style.border = '3px solid #4CAF50';
    }

    document.getElementById('game-messages').innerHTML += `<br><h2>${finalMessage}</h2>`;
    saveGame();
    updateUI(); 
}
// === ENDE DER BATTLE-FUNKTION ===


// --- Pack-√ñffnung (mit neuer Datenstruktur) ---
async function openPack() {
    const packButton = document.getElementById('open-pack-button');
    if (coins < 3) {
        document.getElementById('game-messages').innerHTML = "FEHLER: Du brauchst 3 M√ºnzen!";
        packButton.classList.add('shake-button');
        await delay(400); 
        packButton.classList.remove('shake-button');
        return;
    }

    packButton.disabled = true;
    document.getElementById('start-battle-button').disabled = true;

    coins -= 3;
    const newCard = drawCard(); // Die neue Karte ist jetzt ein Objekt {id, name, level, xp}
    collection.push(newCard); // F√ºge das Objekt zur Collection hinzu
    
    saveGame(); 
    updateUI(); 
    
    const baseStats = getCharacterBaseStats(newCard.name);

    const overlay = document.getElementById('pack-opening-overlay');
    const cardRevealContainer = document.getElementById('card-reveal-container');
    const revealedCardImage = document.getElementById('revealed-card-image');
    const revealedCardInfo = document.getElementById('revealed-card-info');

    overlay.classList.add('active');
    cardRevealContainer.classList.remove('revealed'); 
    revealedCardImage.style.backgroundImage = `url('${IMAGE_MAP[newCard.name] || IMAGE_MAP["Standard"]}')`;
    revealedCardInfo.innerHTML = ``; 

    await delay(500); 

    cardRevealContainer.classList.add('revealed');
    
    await delay(1000); 

    revealedCardInfo.innerHTML = `
        **${newCard.name}** (ID: ${newCard.id})<br>
        (${baseStats.rarity})<br>
        ATK: ${baseStats.atk}, LUCK: ${baseStats.luck}%
    `;

    document.getElementById('game-messages').innerHTML = `üéâ Gl√ºckwunsch! Du hast gezogen: **${newCard.name}** (${baseStats.rarity})!`;
    
    await new Promise(resolve => {
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                overlay.classList.remove('active');
                overlay.onclick = null; 
                resolve();
            }
        };
    });
    
    packButton.disabled = false;
    document.getElementById('start-battle-button').disabled = false;

    saveGame();
    updateUI();
}


// 3. SPIELSTAND SPEICHERN (LOCAL STORAGE)
function saveGame() {
    localStorage.setItem('brainrotCoins', coins);
    localStorage.setItem('brainrotCollection', JSON.stringify(collection));
    localStorage.setItem('brainrotNextCardId', nextCardId);
}


// 4. UI-MANIPULATION

function updateUI() {
    // 1. M√ºnzen aktualisieren
    document.getElementById('coin-display').textContent = `M√ºnzen: ${coins}`;
    
    // 2. Sammlung aktualisieren (DEUTLICH KOMPLEXER JETZT)
    const collectionList = document.getElementById('collection-list');
    collectionList.innerHTML = ''; 
    
    // Sortiere nach Name und Level
    const sortedCollection = [...collection].sort((a, b) => {
        if (a.name < b.name) return -1;
        if (a.name > b.name) return 1;
        return b.level - a.level; // Innerhalb des Namens nach Level absteigend
    });

    sortedCollection.forEach(card => {
        const currentStats = getCharacterCurrentStats(card);
        const baseStats = getCharacterBaseStats(card.name);

        const li = document.createElement('li');
        li.className = 'card-list-item';
        
        li.innerHTML = `
            <div>
                <strong>${card.name}</strong> (Lv. ${card.level}) (ID: ${card.id}) - ${baseStats.rarity}<br>
                ATK: ${currentStats.atk}, LUCK: ${currentStats.luck}% | XP: ${card.xp}/${XP_PER_LEVEL * card.level}
            </div>
            <div>
                <button class="select-main" onclick="setSynthMain(${card.id})">Haupt</button>
                <button class="select-sacrifice" onclick="setSynthSacrifice(${card.id})">Opfer</button>
            </div>
        `;
        collectionList.appendChild(li);
    });
    
    // 3. Auswahlfeld f√ºr den Kampf aktualisieren (Nur Karten Level 1+ w√§hlen)
    const charSelect = document.getElementById('char-select');
    const selectedId = charSelect.value;
    charSelect.innerHTML = '';

    const selectableCards = collection.filter(card => card.level > 0);
    
    if (selectableCards.length === 0) {
        const option = document.createElement('option');
        option.textContent = "Keine K√§mpfer verf√ºgbar!";
        charSelect.appendChild(option);
    } else {
        selectableCards.forEach(card => {
            const stats = getCharacterCurrentStats(card);
            const option = document.createElement('option');
            option.value = card.id;
            option.textContent = `${card.name} (Lv. ${card.level}) - ATK: ${stats.atk}`;
            if (String(card.id) === selectedId) {
                option.selected = true;
            }
            charSelect.appendChild(option);
        });
        // Setze selectedCard auf das ausgew√§hlte Objekt
        const currentSelectionId = parseInt(charSelect.value);
        selectedCard = collection.find(c => c.id === currentSelectionId) || selectableCards[0];
    }

    // 4. Synth-Status aktualisieren
    updateSynthUI();
}

function updateSynthUI() {
    const mainCard = collection.find(c => c.id === synthMainCardId);
    const sacrificeCard = collection.find(c => c.id === synthSacrificeCardId);
    const synthButton = document.getElementById('start-synth-button');
    const status = document.getElementById('synth-status');

    document.getElementById('synth-main-card').textContent = `Hauptkarte: ${mainCard ? mainCard.name + ' (Lv. ' + mainCard.level + ')' : 'Keine'}`;
    document.getElementById('synth-sacrifice-card').textContent = `Opferkarte: ${sacrificeCard ? sacrificeCard.name + ' (Lv. ' + sacrificeCard.level + ')' : 'Keine'}`;

    let canSynth = false;
    if (mainCard && sacrificeCard) {
        if (mainCard.id === sacrificeCard.id) {
            status.textContent = "FEHLER: Haupt- und Opferkarte m√ºssen unterschiedlich sein!";
        } else if (mainCard.name !== sacrificeCard.name) {
            status.textContent = "FEHLER: Karten m√ºssen vom gleichen Charakter sein!";
        } else if (mainCard.level >= 10) {
            status.textContent = "FEHLER: Hauptkarte hat Max-Level erreicht (10)!";
        } else {
            const baseXP = getCharacterBaseStats(mainCard.name).rarity === "Legend√§r" ? 300 : 50; // Vereinfachte XP-Anzeige
            status.textContent = `Bereit! ${mainCard.name} erh√§lt ~${baseXP} XP.`;
            canSynth = true;
        }
    } else {
        status.textContent = "W√§hle Haupt- und Opferkarte.";
    }

    synthButton.disabled = !canSynth;
}

// 5. KLICK-HANDLER F√úR BUTTONS und SYNTH

function setSynthMain(cardId) {
    synthMainCardId = cardId;
    updateSynthUI();
}

function setSynthSacrifice(cardId) {
    synthSacrificeCardId = cardId;
    updateSynthUI();
}

function handleSynthClick() {
    const message = synthCharacter(synthMainCardId, synthSacrificeCardId);
    document.getElementById('game-messages').innerHTML = `<h2>${message}</h2>`;
    updateUI();
}


async function handleFightClick() {
    const selectedId = parseInt(document.getElementById('char-select').value);
    selectedCard = collection.find(c => c.id === selectedId);
    
    if (!selectedCard) {
        document.getElementById('game-messages').innerHTML = "Du musst einen K√§mpfer ausw√§hlen!";
        return;
    }
    
    // Gegner ist immer eine zuf√§llige Basis-Karte (kein Level-System f√ºr Gegner)
    const opponentBase = drawCard();
    opponentCard = getCharacterBaseStats(opponentBase.name);

    await battle(); 
    updateUI();
}

async function handlePackClick() {
    await openPack();
}

// Initialer Aufruf, wenn die Seite geladen wird
window.onload = () => {
    // Initialisiere selectedCard beim Laden, falls Karten existieren
    const initialSelect = document.getElementById('char-select');
    if (initialSelect.options.length > 0) {
        const currentSelectionId = parseInt(initialSelect.value);
        selectedCard = collection.find(c => c.id === currentSelectionId);
    }
    updateUI();
};

// --- ENDE DES JAVASCRIPT CODES ---
</script>
</body>
</html>
