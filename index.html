<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Italian Brainrot TCG: La Sfida</title>
    
    <style>
/* --- CSS f√ºr das Design --- */
.brainrot-game {
    padding: 25px;
    max-width: 600px;
    margin: 20px auto;
    border: 3px solid #d32f2f; /* Rot f√ºr Italian Vibe */
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    font-family: 'Arial', sans-serif;
}
.brainrot-game h2 {
    color: #d32f2f;
    text-align: center;
    border-bottom: 2px solid #ccc;
    padding-bottom: 10px;
    margin-top: 0;
}
.coin-display {
    font-size: 26px;
    font-weight: bold;
    color: #ffc107; /* Gold/Gelb f√ºr M√ºnzen */
    text-shadow: 1px 1px 1px #333;
    text-align: center;
    margin-bottom: 20px;
}
.fight-button, .pack-button {
    width: 100%;
    padding: 12px;
    margin-bottom: 10px;
    border: none;
    border-radius: 6px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s;
}
.fight-button {
    background-color: #d32f2f; /* Rot */
    color: white;
}
.fight-button:hover {
    background-color: #c62828;
}
.pack-button {
    background-color: #1976d2; /* Blau */
    color: white;
}
.pack-button:hover {
    background-color: #1565c0;
}
#char-select {
    width: 100%;
    padding: 10px;
    margin-bottom: 15px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 15px;
}
#game-messages {
    padding: 15px;
    background-color: #e0f7fa;
    border: 1px solid #b2ebf2;
    border-radius: 4px;
    margin-top: 15px;
    min-height: 50px;
    white-space: pre-wrap;
}
#collection-list li {
    list-style-type: none;
    padding: 5px 0;
    border-bottom: 1px dashed #eee;
}
#collection-list {
    padding-left: 0;
}

/* --- KAMPF VISUALISIERUNG --- */
.fight-container {
    display: flex;
    justify-content: space-around;
    align-items: flex-start;
    margin: 20px 0;
    text-align: center;
}
.fighter-panel {
    width: 45%;
    background-color: #eee;
    padding: 10px;
    border-radius: 8px;
    min-height: 250px; /* Einheitliche H√∂he */
    /* F√ºgt eine Transition f√ºr weiche √úberg√§nge hinzu */
    transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
}
.char-img {
    width: 100%; 
    max-width: 120px;
    height: auto;
    border: 3px solid #333;
    border-radius: 4px;
    margin-bottom: 5px;
}
.vs-text {
    font-size: 24px;
    font-weight: bold;
    color: #d32f2f;
    line-height: 150px; 
}
#player-stats, #opponent-stats {
    font-weight: bold;
    min-height: 30px;
    margin: 5px 0 0 0;
}

/* --- NEUE CSS-ANIMATIONEN F√úR DEN ANGRIFF --- */

/* Animation f√ºr den Spieler (bewegt sich nach rechts) */
@keyframes attack-right {
    0% { transform: translateX(0); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
    50% { transform: translateX(15px); box-shadow: 0 0 15px rgba(211, 47, 47, 0.8); } /* Roter Schatten beim Angriff */
    100% { transform: translateX(0); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
}

/* Animation f√ºr den Gegner (bewegt sich nach links) */
@keyframes attack-left {
    0% { transform: translateX(0); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
    50% { transform: translateX(-15px); box-shadow: 0 0 15px rgba(25, 118, 210, 0.8); } /* Blauer Schatten beim Angriff */
    100% { transform: translateX(0); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
}

/* Klasse, die der Spieler-K√§mpfer erh√§lt, wenn er angreift */
.fighter-panel.attacking-player {
    animation: attack-right 0.3s ease-in-out;
}

/* Klasse, die der Gegner-K√§mpfer erh√§lt, wenn er angreift */
.fighter-panel.attacking-opponent {
    animation: attack-left 0.3s ease-in-out;
}

/* Zus√§tzlicher visueller Effekt f√ºr den Angegriffenen (Zittern) */
.fighter-panel.hit {
    animation: shake 0.2s;
    border-color: #ff0000;
}

@keyframes shake {
  0% { transform: translate(1px, 1px) rotate(0deg); }
  25% { transform: translate(-1px, -2px) rotate(-1deg); }
  50% { transform: translate(-3px, 0px) rotate(1deg); }
  75% { transform: translate(1px, 2px) rotate(0deg); }
  100% { transform: translate(0px, 0px) rotate(0deg); }
}

</style>
</head>
<body>

<div class="brainrot-game">
    <h2>Italian Brainrot TCG: La Sfida ü§å</h2>
    
    <div id="coin-display" class="coin-display">M√ºnzen: 0</div>
    
    <h3>W√§hle deinen K√§mpfer:</h3>
    <select id="char-select"></select>
    
    <button class="fight-button" id="start-battle-button" onclick="handleFightClick()">‚öîÔ∏è Starte Kampf</button>
    <button class="pack-button" onclick="handlePackClick()">üéÅ Pack √∂ffnen (3 M√ºnzen)</button>
    
    <hr>

    <h3>Letzter Kampf:</h3>
    <div id="fight-visuals" class="fight-container">
        <div class="fighter-panel" id="player-fighter">
            <img id="player-img" src="[URL_ZU_EINEM_STANDARD_BILD]" alt="Dein K√§mpfer" class="char-img">
            <p id="player-stats">W√§hle deinen K√§mpfer</p>
        </div>
        <div class="vs-text">VS</div>
        <div class="fighter-panel" id="opponent-fighter">
             <img id="opponent-img" src="[URL_ZU_EINEM_STANDARD_BILD]" alt="Gegner" class="char-img">
            <p id="opponent-stats">Gegner wartet</p>
        </div>
    </div>
    
    <h3>Nachrichten:</h3>
    <div id="game-messages">Willkommen in Italien! W√§hle deinen Brainrot!</div>
    
    <hr>
    
    <h3>Deine Sammlung:</h3>
    <ul id="collection-list"></ul>
</div>

<script>
// --- START DES JAVASCRIPT CODES ---

// 1. SPIELDATEN
const CHARACTER_POOL = [
    { name: "Gert", atk: 50, luck: 70, rarity: "Legend√§r", weight: 2 },
    { name: "Ciro", atk: 80, luck: 30, rarity: "Episch", weight: 5 },
    { name: "Pino", atk: 65, luck: 55, rarity: "Selten", weight: 10 },
    { name: "Maria", atk: 40, luck: 80, rarity: "Selten", weight: 10 },
    { name: "Il Baffo", atk: 75, luck: 45, rarity: "Ungew√∂hnlich", weight: 15 },
    { name: "La Nonna", atk: 35, luck: 90, rarity: "Ungew√∂hnlich", weight: 15 },
    { name: "Luca", atk: 50, luck: 60, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Giulia", atk: 45, luck: 65, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Franco", atk: 60, luck: 50, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Silvia", atk: 30, luck: 70, rarity: "Gew√∂hnlich", weight: 20 },
];

// --- BILDER DATENSTRUKTUR ---
const IMAGE_MAP = {
    "Gert": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603658844.jpg", 
    "Ciro": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603775510.jpg",
    "Pino": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604336272.jpg", 
    "Maria": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603976186.jpg",
    "Il Baffo": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603873171.jpg", 
    "La Nonna": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604469456.jpg",
    "Luca": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604194583.jpg",
    "Giulia": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604449953.jpg",
    "Franco": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604049720.jpg",
    "Silvia": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604414423.jpg",
    "Standard": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760651693496.jpg" 
};

// --- GLOBALE ZUSTANDSVARIABLEN ---
let collection = JSON.parse(localStorage.getItem('brainrotCollection')) || { "Luca": 1, "Franco": 1, "Pino": 1 };
let coins = parseInt(localStorage.getItem('brainrotCoins')) || 0; 

let isBattling = false;     
let selectedCard = null;  
let opponentCard = null;  


const DRAW_WEIGHTS = CHARACTER_POOL.flatMap(char => 
    Array(char.weight).fill(char)
);

// 2. SPIELLOGIK (Kernfunktionen)

// Hilfsfunktion f√ºr die rundenbasierte Logik (Delay)
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// --- NEUE FUNKTION F√úR DIE ANIMATION ---
function animateAttack(attackerElementId, defenderElementId) {
    return new Promise(resolve => {
        const attacker = document.getElementById(attackerElementId);
        const defender = document.getElementById(defenderElementId);
        
        // 1. Animation starten
        attacker.classList.add(`attacking-${attackerElementId.split('-')[0]}`);
        defender.classList.add('hit'); // Verteidiger zittert
        
        // 2. Event-Listener f√ºr das Ende der Animation
        function handleAnimationEnd() {
            // 3. Klassen entfernen und Promise aufl√∂sen
            attacker.classList.remove(`attacking-${attackerElementId.split('-')[0]}`);
            defender.classList.remove('hit');
            attacker.removeEventListener('animationend', handleAnimationEnd);
            resolve();
        }
        
        attacker.addEventListener('animationend', handleAnimationEnd);
    });
}


function calculateStrength(charData) {
    const baseAtk = charData.atk;
    const luckRoll = Math.floor(Math.random() * 100) + 1;
    let bonus = 0;
    if (luckRoll <= charData.luck) {
        bonus = (baseAtk * 0.33);
    }
    return baseAtk + bonus;
}

function drawCard() {
    const randomIndex = Math.floor(Math.random() * DRAW_WEIGHTS.length);
    return DRAW_WEIGHTS[randomIndex];
}

// === ASYNCHRONE BATTLE-FUNKTION (LIVE-KAMPF-STRUKTUR MIT ANIMATION) ===
async function battle() {
    if (isBattling || !selectedCard || !opponentCard) return;

    isBattling = true; 
    
    let playerHP = 100;
    let opponentHP = 100;
    
    document.getElementById('start-battle-button').disabled = true;

    // KAMPF VISUALISIERUNG START
    document.getElementById('player-img').src = IMAGE_MAP[selectedCard.name] || IMAGE_MAP["Standard"];
    document.getElementById('opponent-img').src = IMAGE_MAP[opponentCard.name] || IMAGE_MAP["Standard"];
    
    document.getElementById('player-fighter').style.border = '';
    document.getElementById('opponent-fighter').style.border = '';
    
    document.getElementById('player-stats').innerHTML = `**${selectedCard.name}**<br>ATK: ${selectedCard.atk}, LUCK: ${selectedCard.luck}%<br>HP: ${playerHP}`;
    document.getElementById('opponent-stats').innerHTML = `**${opponentCard.name}**<br>ATK: ${opponentCard.atk}, LUCK: ${opponentCard.luck}%<br>HP: ${opponentHP}`;

    document.getElementById('game-messages').innerHTML = `<h2 class="battle-title">‚öîÔ∏è KAMPF STARTET! ${selectedCard.name} vs. ${opponentCard.name} ‚öîÔ∏è</h2>`;

    
    // --- HAUPTSCHLEIFE F√úR DEN RUNDENBASIERTEN KAMPF ---
    while (playerHP > 0 && opponentHP > 0) {
        
        // --- 1. RUNDE: SPIELER-ANGRIFF ---
        
        // **NEU:** Animation VOR dem Schaden anzeigen
        await animateAttack('player-fighter', 'opponent-fighter');
        await delay(300); // Kurze Pause nach der Animation, bevor der Text erscheint
        
        let playerStrength = calculateStrength(selectedCard);
        let playerDamage = Math.max(1, Math.round(playerStrength / 10)); 
        
        let critMessage = "";
        if (playerStrength > selectedCard.atk) { 
            playerDamage = Math.round(playerDamage * 1.5); 
            critMessage = "‚≠ê Kritischer Gl√ºckstreffer!";
        }
        
        opponentHP -= playerDamage;
        opponentHP = Math.max(0, opponentHP);

        document.getElementById('game-messages').innerHTML += `<p>üí• ${selectedCard.name} greift an! Verursacht ${playerDamage} Schaden. ${critMessage}</p>`;
        
        // HP-Anzeige aktualisieren
        document.getElementById('opponent-stats').innerHTML = `**${opponentCard.name}**<br>ATK: ${opponentCard.atk}, LUCK: ${opponentCard.luck}%<br>HP: ${opponentHP}`;
        
        if (opponentHP <= 0) break;

        // --- 2. RUNDE: GEGNER-ANGRIFF ---
        await delay(1000); // Kurze Pause zwischen den Z√ºgen
        
        // **NEU:** Animation VOR dem Schaden anzeigen
        await animateAttack('opponent-fighter', 'player-fighter');
        await delay(300); // Kurze Pause nach der Animation, bevor der Text erscheint

        let opponentStrength = calculateStrength(opponentCard);
        let opponentDamage = Math.max(1, Math.round(opponentStrength / 10));
        
        let opponentCritMessage = "";
        if (opponentStrength > opponentCard.atk) {
            opponentDamage = Math.round(opponentDamage * 1.5);
            opponentCritMessage = "‚≠ê Kritischer Gl√ºckstreffer!";
        }
        
        playerHP -= opponentDamage;
        playerHP = Math.max(0, playerHP);

        document.getElementById('game-messages').innerHTML += `<p>üíî ${opponentCard.name} schl√§gt zur√ºck! Erleidet ${opponentDamage} Schaden. ${opponentCritMessage}</p>`;

        // HP-Anzeige aktualisieren
        document.getElementById('player-stats').innerHTML = `**${selectedCard.name}**<br>ATK: ${selectedCard.atk}, LUCK: ${selectedCard.luck}%<br>HP: ${playerHP}`;
    }

    // --- KAMPF ENDE & ERGEBNIS ---
    isBattling = false; 
    document.getElementById('start-battle-button').disabled = false; 
    
    await delay(2000); 

    let finalMessage = "";
    if (playerHP > 0) {
        coins += 1;
        finalMessage = `üèÜ **SIEG!** Du hast gewonnen und 1 Coin erhalten!`;
        document.getElementById('player-fighter').style.border = '3px solid #4CAF50';
        document.getElementById('opponent-fighter').style.border = '3px solid #F44336';
    } else {
        finalMessage = `üòî **NIEDERLAGE!** Du hast verloren.`;
        document.getElementById('player-fighter').style.border = '3px solid #F44336';
        document.getElementById('opponent-fighter').style.border = '3px solid #4CAF50';
    }

    document.getElementById('game-messages').innerHTML += `<br><h2>${finalMessage}</h2>`;
    saveGame();
    updateUI(); 
}
// === ENDE DER BATTLE-FUNKTION ===


function openPack() {
    if (coins < 3) {
        return "FEHLER: Du brauchst 3 M√ºnzen!";
    }

    coins -= 3;
    const newCard = drawCard();
    collection[newCard.name] = (collection[newCard.name] || 0) + 1;

    saveGame();
    return `üéâ Gl√ºckwunsch! Du hast gezogen: **${newCard.name}** (${newCard.rarity})!\nATK: ${newCard.atk}, LUCK: ${newCard.luck}`;
}

// 3. SPIELSTAND SPEICHERN (LOCAL STORAGE)
function saveGame() {
    localStorage.setItem('brainrotCoins', coins);
    localStorage.setItem('brainrotCollection', JSON.stringify(collection));
}


// 4. UI-MANIPULATION

function updateUI() {
    // 1. M√ºnzen aktualisieren
    document.getElementById('coin-display').textContent = `M√ºnzen: ${coins}`;
    
    // 2. Sammlung aktualisieren
    const collectionList = document.getElementById('collection-list');
    collectionList.innerHTML = ''; 
    
    const sortedCollection = Object.keys(collection)
        .filter(name => collection[name] > 0)
        .map(name => {
            const charData = CHARACTER_POOL.find(c => c.name === name);
            return { name, count: collection[name], charData };
        })
        .sort((a, b) => b.charData.atk - a.charData.atk);

    sortedCollection.forEach(({ name, count, charData }) => {
        const li = document.createElement('li');
        li.className = 'card-list-item';
        li.innerHTML = `<strong>${count}x ${name}</strong> (${charData.rarity}) - ATK: ${charData.atk}, LUCK: ${charData.luck}%`;
        collectionList.appendChild(li);
    });
    
    // 3. Auswahlfeld aktualisieren
    const charSelect = document.getElementById('char-select');
    const selectedValue = charSelect.value;
    charSelect.innerHTML = '';

    const ownedChars = Object.keys(collection).filter(name => collection[name] > 0);
    
    if (ownedChars.length === 0) {
        const option = document.createElement('option');
        option.textContent = "Keine K√§mpfer verf√ºgbar!";
        charSelect.appendChild(option);
    } else {
        ownedChars.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            if (name === selectedValue) {
                option.selected = true;
            }
            charSelect.appendChild(option);
        });
        if (!ownedChars.includes(selectedValue) && ownedChars.length > 0) {
             charSelect.value = ownedChars[0];
        }
    }
}

// 5. KLICK-HANDLER F√úR BUTTONS

async function handleFightClick() {
    const selectedCharName = document.getElementById('char-select').value;
    
    if (selectedCharName === "Keine K√§mpfer verf√ºgbar!" || !selectedCharName) {
        document.getElementById('game-messages').innerHTML = "Du musst erst ein Pack √∂ffnen und einen K√§mpfer ausw√§hlen!";
        return;
    }
    
    selectedCard = CHARACTER_POOL.find(c => c.name === selectedCharName);
    opponentCard = drawCard(); 

    // await battle() ist korrekt
    await battle(); 
    updateUI();
}

function handlePackClick() {
    const result = openPack();
    document.getElementById('game-messages').innerHTML = result;
    updateUI();
}

// Initialer Aufruf, wenn die Seite geladen wird
window.onload = updateUI;

// --- ENDE DES JAVASCRIPT CODES ---
</script>
</body>
</html>
