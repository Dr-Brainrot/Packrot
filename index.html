<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Italian Brainrot TCG: La Sfida</title>
    
    <style>
/* --- CSS f√ºr das Design --- */
body {
    background-color: #f0f2f5; 
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
}
.brainrot-game {
    padding: 25px;
    max-width: 600px;
    width: 90%; 
    margin: 20px auto;
    border: 3px solid #d32f2f; 
    background-color: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    font-family: 'Arial', sans-serif;
    position: relative; 
    overflow: hidden; 
}
.brainrot-game h2 {
    color: #d32f2f;
    text-align: center;
    border-bottom: 2px solid #ccc;
    padding-bottom: 10px;
    margin-top: 0;
}
.coin-display {
    font-size: 26px;
    font-weight: bold;
    color: #ffc107; 
    text-shadow: 1px 1px 1px #333;
    text-align: center;
    margin-bottom: 20px;
}
.fight-button, .pack-button {
    width: 100%;
    padding: 12px;
    margin-bottom: 10px;
    border: none;
    border-radius: 6px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
}
.fight-button {
    background-color: #d32f2f; 
    color: white;
}
.fight-button:hover {
    background-color: #c62828;
}
.pack-button {
    background-color: #1976d2; 
    color: white;
}
.pack-button:hover {
    background-color: #1565c0;
}

/* NEUE: Button zittern bei Fehler */
@keyframes shake-animation {
    0%, 100% { transform: translateX(0); background-color: #1976d2; }
    20%, 60% { transform: translateX(-5px); background-color: #FF5722; } /* Orange/Rot bei Fehler */
    40%, 80% { transform: translateX(5px); background-color: #FF5722; }
}
.shake-button {
    animation: shake-animation 0.4s ease-in-out;
}

#char-select {
    width: 100%;
    padding: 10px;
    margin-bottom: 15px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 15px;
}
#game-messages {
    padding: 15px;
    background-color: #e0f7fa;
    border: 1px solid #b2ebf2;
    border-radius: 4px;
    margin-top: 15px;
    min-height: 50px;
    white-space: pre-wrap;
}
#collection-list li {
    list-style-type: none;
    padding: 5px 0;
    border-bottom: 1px dashed #eee;
}
#collection-list {
    padding-left: 0;
}

/* --- KAMPF VISUALISIERUNG --- */
.fight-container {
    display: flex;
    justify-content: space-around;
    align-items: flex-start;
    margin: 20px 0;
    text-align: center;
}
.fighter-panel {
    width: 45%;
    background-color: #eee;
    padding: 10px;
    border-radius: 8px;
    min-height: 250px; 
    transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
    position: relative; /* Wichtig f√ºr Schadens-Popup */
}
.char-img {
    width: 100%; 
    max-width: 120px;
    height: auto;
    border: 3px solid #333;
    border-radius: 4px;
    margin-bottom: 5px;
}
.vs-text {
    font-size: 24px;
    font-weight: bold;
    color: #d32f2f;
    line-height: 150px; 
}
.fighter-stats-info {
    font-weight: bold;
    min-height: 30px;
    margin: 5px 0 0 0;
}
.stats-text {
    margin-top: 5px;
}


/* NEU: HP-Balken Styling */
.hp-bar-container {
    width: 100%;
    height: 15px;
    background-color: #f44336; /* Rot als Hintergrund (leere HP) */
    border-radius: 7px;
    margin-top: 5px;
    overflow: hidden;
}
.hp-bar-fill {
    height: 100%;
    width: 100%; /* Startet bei 100% */
    background-color: #4CAF50; /* Gr√ºn f√ºr volle HP */
    transition: width 0.5s ease-out; /* Sanfte Animation der HP-Reduzierung */
}
.low-hp {
    background-color: #f44336; /* Rot bei niedriger HP */
}

/* --- CSS-ANIMATIONEN F√úR DEN ANGRIFF (Unver√§ndert) --- */
@keyframes attack-right {
    0% { transform: translateX(0); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
    50% { transform: translateX(15px); box-shadow: 0 0 15px rgba(211, 47, 47, 0.8); }
    100% { transform: translateX(0); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
}
@keyframes attack-left {
    0% { transform: translateX(0); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
    50% { transform: translateX(-15px); box-shadow: 0 0 15px rgba(25, 118, 210, 0.8); }
    100% { transform: translateX(0); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
}
.fighter-panel.attacking-player { animation: attack-right 0.3s ease-in-out; }
.fighter-panel.attacking-opponent { animation: attack-left 0.3s ease-in-out; }
.fighter-panel.hit { animation: shake 0.2s; border-color: #ff0000; }
@keyframes shake {
  0% { transform: translate(1px, 1px) rotate(0deg); } 25% { transform: translate(-1px, -2px) rotate(-1deg); }
  50% { transform: translate(-3px, 0px) rotate(1deg); } 75% { transform: translate(1px, 2px) rotate(0deg); }
  100% { transform: translate(0px, 0px) rotate(0deg); }
}

/* NEU: Schadens-Popup Styling */
.damage-popup {
    position: absolute;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    color: red;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 1px 1px 3px black;
    opacity: 0;
    animation: floatup 1s forwards;
    pointer-events: none; /* Klicks durchlassen */
}
.damage-popup.crit {
    color: #ffc107; /* Gold/Gelb f√ºr Kritischen Schaden */
    font-size: 30px;
}
@keyframes floatup {
    0% { opacity: 1; transform: translate(-50%, 0); }
    100% { opacity: 0; transform: translate(-50%, -50px); }
}

/* --- PACK-√ñFFNUNGS-ANIMATION (Unver√§ndert) --- */
#pack-opening-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000; 
    opacity: 0; 
    visibility: hidden;
    transition: opacity 0.3s ease-in-out;
}
#pack-opening-overlay.active {
    opacity: 1;
    visibility: visible;
}
.card-reveal-container {
    perspective: 1000px; 
    width: 180px; 
    height: 250px;
    position: relative;
    cursor: pointer;
}
.card-front, .card-back {
    width: 100%;
    height: 100%;
    position: absolute;
    backface-visibility: hidden; 
    border-radius: 8px;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
    transition: transform 0.8s ease-in-out;
    background-size: cover;
    background-position: center;
}
.card-front {
    background-image: url('https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/card_back.png'); 
    transform: rotateY(0deg);
}
.card-back {
    background-image: url('https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760651693496.jpg'); 
    transform: rotateY(180deg);
    display: flex;
    flex-direction: column;
    justify-content: flex-end; 
    align-items: center;
    color: white;
    text-shadow: 1px 1px 3px black;
    padding: 10px;
    box-sizing: border-box;
    font-size: 14px;
    text-align: center;
    font-weight: bold;
}
.card-reveal-container.revealed .card-front {
    transform: rotateY(-180deg);
}
.card-reveal-container.revealed .card-back {
    transform: rotateY(0deg);
}
#revealed-card-info {
    position: absolute;
    bottom: 10px;
    width: 100%;
    text-align: center;
    padding: 0 5px;
    box-sizing: border-box;
    background-color: rgba(0,0,0,0.4); 
    border-radius: 0 0 8px 8px;
    padding-top: 5px;
    padding-bottom: 5px;
}
    </style>
</head>
<body>

<div class="brainrot-game">
    <h2>Italian Brainrot TCG: La Sfida ü§å</h2>
    
    <div id="coin-display" class="coin-display">M√ºnzen: 0</div>
    
    <h3>W√§hle deinen K√§mpfer:</h3>
    <select id="char-select"></select>
    
    <button class="fight-button" id="start-battle-button" onclick="handleFightClick()">‚öîÔ∏è Starte Kampf</button>
    <button class="pack-button" id="open-pack-button" onclick="handlePackClick()">üéÅ Pack √∂ffnen (3 M√ºnzen)</button>
    
    <hr>

    <h3>Letzter Kampf:</h3>
    <div id="fight-visuals" class="fight-container">
        <div class="fighter-panel" id="player-fighter">
            <img id="player-img" src="[URL_ZU_EINEM_STANDARD_BILD]" alt="Dein K√§mpfer" class="char-img">
            <div class="fighter-stats-info">
                <p id="player-stats" class="stats-text">W√§hle deinen K√§mpfer</p>
                <div class="hp-bar-container">
                    <div id="player-hp-fill" class="hp-bar-fill"></div>
                </div>
            </div>
        </div>
        <div class="vs-text">VS</div>
        <div class="fighter-panel" id="opponent-fighter">
             <img id="opponent-img" src="[URL_ZU_EINEM_STANDARD_BILD]" alt="Gegner" class="char-img">
            <div class="fighter-stats-info">
                <p id="opponent-stats" class="stats-text">Gegner wartet</p>
                <div class="hp-bar-container">
                    <div id="opponent-hp-fill" class="hp-bar-fill"></div>
                </div>
            </div>
        </div>
    </div>
    
    <h3>Nachrichten:</h3>
    <div id="game-messages">Willkommen in Italien! W√§hle deinen Brainrot!</div>
    
    <hr>
    
    <h3>Deine Sammlung:</h3>
    <ul id="collection-list"></ul>

    
    <div id="pack-opening-overlay">
        <div class="card-reveal-container" id="card-reveal-container">
            <div class="card-front"></div>
            <div class="card-back" id="revealed-card-image">
                <div id="revealed-card-info"></div>
            </div>
        </div>
    </div>
</div>

<script>
// --- START DES JAVASCRIPT CODES ---

// 1. SPIELDATEN
const CHARACTER_POOL = [
    { name: "Gert", atk: 50, luck: 70, rarity: "Legend√§r", weight: 2 },
    { name: "Ciro", atk: 80, luck: 30, rarity: "Episch", weight: 5 },
    { name: "Pino", atk: 65, luck: 55, rarity: "Selten", weight: 10 },
    { name: "Maria", atk: 40, luck: 80, rarity: "Selten", weight: 10 },
    { name: "Il Baffo", atk: 75, luck: 45, rarity: "Ungew√∂hnlich", weight: 15 },
    { name: "La Nonna", atk: 35, luck: 90, rarity: "Ungew√∂hnlich", weight: 15 },
    { name: "Luca", atk: 50, luck: 60, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Giulia", atk: 45, luck: 65, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Franco", atk: 60, luck: 50, rarity: "Gew√∂hnlich", weight: 20 },
    { name: "Silvia", atk: 30, luck: 70, rarity: "Gew√∂hnlich", weight: 20 },
];

// --- BILDER DATENSTRUKTUR ---
const IMAGE_MAP = {
    "Gert": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603658844.jpg", 
    "Ciro": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603775510.jpg",
    "Pino": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604336272.jpg", 
    "Maria": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603976186.jpg",
    "Il Baffo": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760603873171.jpg", 
    "La Nonna": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604469456.jpg",
    "Luca": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604194583.jpg",
    "Giulia": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604449953.jpg",
    "Franco": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604049720.jpg",
    "Silvia": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760604414423.jpg",
    "Standard": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/1760651693496.jpg",
    "CardBack": "https://raw.githubusercontent.com/Dr-Brainrot/Packrot/main/bilder/card_back.png" 
};

// --- GLOBALE ZUSTANDSVARIABLEN ---
let collection = JSON.parse(localStorage.getItem('brainrotCollection')) || { "Luca": 1, "Franco": 1, "Pino": 1 };
let coins = parseInt(localStorage.getItem('brainrotCoins')) || 0; 

let isBattling = false;     
let selectedCard = null;  
let opponentCard = null;  


const DRAW_WEIGHTS = CHARACTER_POOL.flatMap(char => 
    Array(char.weight).fill(char)
);

// 2. SPIELLOGIK (Kernfunktionen)

// Hilfsfunktion f√ºr die rundenbasierte Logik (Delay)
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// --- NEUE FUNKTION F√úR SCHADENS-POPUP ---
function showDamagePopup(elementId, damage, isCrit) {
    const fighterPanel = document.getElementById(elementId);
    const popup = document.createElement('div');
    popup.textContent = `-${damage}`;
    popup.classList.add('damage-popup');
    if (isCrit) {
        popup.classList.add('crit');
        popup.textContent = `üí• -${damage}!`;
    }
    
    // Zuf√§llige x-Position leicht links oder rechts von der Mitte
    const randomX = Math.random() * 20 - 10; // -10 bis 10
    popup.style.transform = `translate(calc(-50% + ${randomX}px), 0)`;

    fighterPanel.appendChild(popup);
    
    // Entferne das Popup nach der Animation (1s)
    setTimeout(() => {
        fighterPanel.removeChild(popup);
    }, 1000);
}

// --- NEUE FUNKTION F√úR HP-BALKEN-UPDATE ---
function updateHPBar(hpFillId, currentHP) {
    const hpFill = document.getElementById(hpFillId);
    const percentage = Math.max(0, currentHP);
    hpFill.style.width = `${percentage}%`;
    
    // Farbe √§ndern bei niedriger HP
    if (percentage <= 25) {
        hpFill.classList.add('low-hp');
    } else {
        hpFill.classList.remove('low-hp');
    }
}

// --- NEUE FUNKTION F√úR DIE KAMPF-ANIMATION (Unver√§ndert) ---
function animateAttack(attackerElementId, defenderElementId) {
    return new Promise(resolve => {
        const attacker = document.getElementById(attackerElementId);
        const defender = document.getElementById(defenderElementId);
        
        attacker.classList.add(`attacking-${attackerElementId.split('-')[0]}`);
        defender.classList.add('hit'); 
        
        function handleAnimationEnd() {
            attacker.classList.remove(`attacking-${attackerElementId.split('-')[0]}`);
            defender.classList.remove('hit');
            attacker.removeEventListener('animationend', handleAnimationEnd);
            resolve();
        }
        
        attacker.addEventListener('animationend', handleAnimationEnd);
    });
}


function calculateStrength(charData) {
    const baseAtk = charData.atk;
    const luckRoll = Math.floor(Math.random() * 100) + 1;
    let bonus = 0;
    if (luckRoll <= charData.luck) {
        bonus = (baseAtk * 0.33);
    }
    return baseAtk + bonus;
}

function drawCard() {
    const randomIndex = Math.floor(Math.random() * DRAW_WEIGHTS.length);
    return DRAW_WEIGHTS[randomIndex];
}

// === ASYNCHRONE BATTLE-FUNKTION (MIT HP-BALKEN & SCHADENS-POPUP) ===
async function battle() {
    if (isBattling || !selectedCard || !opponentCard) return;

    isBattling = true; 
    
    let playerHP = 100;
    let opponentHP = 100;
    
    document.getElementById('start-battle-button').disabled = true;
    document.getElementById('open-pack-button').disabled = true;

    // KAMPF VISUALISIERUNG START
    document.getElementById('player-img').src = IMAGE_MAP[selectedCard.name] || IMAGE_MAP["Standard"];
    document.getElementById('opponent-img').src = IMAGE_MAP[opponentCard.name] || IMAGE_MAP["Standard"];
    
    document.getElementById('player-fighter').style.border = '';
    document.getElementById('opponent-fighter').style.border = '';
    
    // Initiales HP-Update
    document.getElementById('player-stats').innerHTML = `**${selectedCard.name}**<br>ATK: ${selectedCard.atk}, LUCK: ${selectedCard.luck}%<br>HP: ${playerHP}`;
    document.getElementById('opponent-stats').innerHTML = `**${opponentCard.name}**<br>ATK: ${opponentCard.atk}, LUCK: ${opponentCard.luck}%<br>HP: ${opponentHP}`;
    updateHPBar('player-hp-fill', playerHP);
    updateHPBar('opponent-hp-fill', opponentHP);


    document.getElementById('game-messages').innerHTML = `<h2 class="battle-title">‚öîÔ∏è KAMPF STARTET! ${selectedCard.name} vs. ${opponentCard.name} ‚öîÔ∏è</h2>`;

    
    // --- HAUPTSCHLEIFE F√úR DEN RUNDENBASIERTEN KAMPF ---
    while (playerHP > 0 && opponentHP > 0) {
        
        // --- 1. RUNDE: SPIELER-ANGRIFF ---
        
        await animateAttack('player-fighter', 'opponent-fighter');
        
        let playerStrength = calculateStrength(selectedCard);
        let playerDamage = Math.max(1, Math.round(playerStrength / 10)); 
        let isPlayerCrit = false;
        
        let critMessage = "";
        if (playerStrength > selectedCard.atk) { 
            playerDamage = Math.round(playerDamage * 1.5); 
            critMessage = "‚≠ê Kritischer Gl√ºckstreffer!";
            isPlayerCrit = true;
        }
        
        opponentHP -= playerDamage;
        opponentHP = Math.max(0, opponentHP);

        // NEU: Schadens-Popup anzeigen
        showDamagePopup('opponent-fighter', playerDamage, isPlayerCrit);
        
        document.getElementById('game-messages').innerHTML += `<p>üí• ${selectedCard.name} greift an! Verursacht ${playerDamage} Schaden. ${critMessage}</p>`;
        
        // NEU: HP-Balken und Text aktualisieren
        document.getElementById('opponent-stats').innerHTML = `**${opponentCard.name}**<br>ATK: ${opponentCard.atk}, LUCK: ${opponentCard.luck}%<br>HP: ${opponentHP}`;
        updateHPBar('opponent-hp-fill', opponentHP);
        
        if (opponentHP <= 0) break;

        // --- 2. RUNDE: GEGNER-ANGRIFF ---
        await delay(1000); 
        
        await animateAttack('opponent-fighter', 'player-fighter');

        let opponentStrength = calculateStrength(opponentCard);
        let opponentDamage = Math.max(1, Math.round(opponentStrength / 10));
        let isOpponentCrit = false;
        
        let opponentCritMessage = "";
        if (opponentStrength > opponentCard.atk) {
            opponentDamage = Math.round(opponentDamage * 1.5);
            opponentCritMessage = "‚≠ê Kritischer Gl√ºckstreffer!";
            isOpponentCrit = true;
        }
        
        playerHP -= opponentDamage;
        playerHP = Math.max(0, playerHP);
        
        // NEU: Schadens-Popup anzeigen
        showDamagePopup('player-fighter', opponentDamage, isOpponentCrit);

        document.getElementById('game-messages').innerHTML += `<p>üíî ${opponentCard.name} schl√§gt zur√ºck! Erleidet ${opponentDamage} Schaden. ${opponentCritMessage}</p>`;

        // NEU: HP-Balken und Text aktualisieren
        document.getElementById('player-stats').innerHTML = `**${selectedCard.name}**<br>ATK: ${selectedCard.atk}, LUCK: ${selectedCard.luck}%<br>HP: ${playerHP}`;
        updateHPBar('player-hp-fill', playerHP);
    }

    // --- KAMPF ENDE & ERGEBNIS ---
    isBattling = false; 
    document.getElementById('start-battle-button').disabled = false; 
    document.getElementById('open-pack-button').disabled = false; 
    
    await delay(2000); 

    let finalMessage = "";
    if (playerHP > 0) {
        coins += 1;
        finalMessage = `üèÜ **SIEG!** Du hast gewonnen und 1 Coin erhalten!`;
        document.getElementById('player-fighter').style.border = '3px solid #4CAF50';
        document.getElementById('opponent-fighter').style.border = '3px solid #F44336';
    } else {
        finalMessage = `üòî **NIEDERLAGE!** Du hast verloren.`;
        document.getElementById('player-fighter').style.border = '3px solid #F44336';
        document.getElementById('opponent-fighter').style.border = '3px solid #4CAF50';
    }

    document.getElementById('game-messages').innerHTML += `<br><h2>${finalMessage}</h2>`;
    saveGame();
    updateUI(); 
}
// === ENDE DER BATTLE-FUNKTION ===


// --- NEUE ASYNCHRONE openPack Funktion (mit Fehler-Feedback) ---
async function openPack() {
    const packButton = document.getElementById('open-pack-button');
    if (coins < 3) {
        document.getElementById('game-messages').innerHTML = "FEHLER: Du brauchst 3 M√ºnzen!";
        
        // NEU: Button zittern lassen
        packButton.classList.add('shake-button');
        await delay(400); // Warten auf das Ende der Shake-Animation
        packButton.classList.remove('shake-button');
        return;
    }

    // Buttons deaktivieren
    packButton.disabled = true;
    document.getElementById('start-battle-button').disabled = true;

    coins -= 3;
    saveGame(); 
    updateUI(); 
    
    const newCard = drawCard();
    collection[newCard.name] = (collection[newCard.name] || 0) + 1;

    const overlay = document.getElementById('pack-opening-overlay');
    const cardRevealContainer = document.getElementById('card-reveal-container');
    const revealedCardImage = document.getElementById('revealed-card-image');
    const revealedCardInfo = document.getElementById('revealed-card-info');

    // Overlay anzeigen und Pack-R√ºckseite einstellen
    overlay.classList.add('active');
    cardRevealContainer.classList.remove('revealed'); 
    revealedCardImage.style.backgroundImage = `url('${IMAGE_MAP[newCard.name] || IMAGE_MAP["Standard"]}')`;
    revealedCardInfo.innerHTML = ``; 

    await delay(500); 

    // Karte umdrehen
    cardRevealContainer.classList.add('revealed');
    
    await delay(1000); 

    // Details der Karte anzeigen
    revealedCardInfo.innerHTML = `
        <strong>${newCard.name}</strong><br>
        (${newCard.rarity})<br>
        ATK: ${newCard.atk}, LUCK: ${newCard.luck}%
    `;

    document.getElementById('game-messages').innerHTML = `üéâ Gl√ºckwunsch! Du hast gezogen: **${newCard.name}** (${newCard.rarity})!`;
    
    // Auf Klick warten, um Overlay zu schlie√üen
    await new Promise(resolve => {
        overlay.onclick = (e) => {
            // Sicherstellen, dass nur ein Klick auf das Overlay (und nicht die Karte selbst) schlie√üt
            if (e.target === overlay) {
                overlay.classList.remove('active');
                overlay.onclick = null; 
                resolve();
            }
        };
    });
    
    // Buttons wieder aktivieren
    packButton.disabled = false;
    document.getElementById('start-battle-button').disabled = false;

    saveGame();
    updateUI();
}


// 3. SPIELSTAND SPEICHERN (LOCAL STORAGE)
function saveGame() {
    localStorage.setItem('brainrotCoins', coins);
    localStorage.setItem('brainrotCollection', JSON.stringify(collection));
}


// 4. UI-MANIPULATION

function updateUI() {
    // 1. M√ºnzen aktualisieren
    document.getElementById('coin-display').textContent = `M√ºnzen: ${coins}`;
    
    // 2. Sammlung aktualisieren
    const collectionList = document.getElementById('collection-list');
    collectionList.innerHTML = ''; 
    
    const sortedCollection = Object.keys(collection)
        .filter(name => collection[name] > 0)
        .map(name => {
            const charData = CHARACTER_POOL.find(c => c.name === name);
            return { name, count: collection[name], charData };
        })
        .sort((a, b) => b.charData.atk - a.charData.atk);

    sortedCollection.forEach(({ name, count, charData }) => {
        const li = document.createElement('li');
        li.className = 'card-list-item';
        li.innerHTML = `<strong>${count}x ${name}</strong> (${charData.rarity}) - ATK: ${charData.atk}, LUCK: ${charData.luck}%`;
        collectionList.appendChild(li);
    });
    
    // 3. Auswahlfeld aktualisieren
    const charSelect = document.getElementById('char-select');
    const selectedValue = charSelect.value;
    charSelect.innerHTML = '';

    const ownedChars = Object.keys(collection).filter(name => collection[name] > 0);
    
    if (ownedChars.length === 0) {
        const option = document.createElement('option');
        option.textContent = "Keine K√§mpfer verf√ºgbar!";
        charSelect.appendChild(option);
    } else {
        ownedChars.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            if (name === selectedValue) {
                option.selected = true;
            }
            charSelect.appendChild(option);
        });
        if (!ownedChars.includes(selectedValue) && ownedChars.length > 0) {
             charSelect.value = ownedChars[0];
        }
    }
}

// 5. KLICK-HANDLER F√úR BUTTONS

async function handleFightClick() {
    const selectedCharName = document.getElementById('char-select').value;
    
    if (selectedCharName === "Keine K√§mpfer verf√ºgbar!" || !selectedCharName) {
        document.getElementById('game-messages').innerHTML = "Du musst erst ein Pack √∂ffnen und einen K√§mpfer ausw√§hlen!";
        return;
    }
    
    selectedCard = CHARACTER_POOL.find(c => c.name === selectedCharName);
    opponentCard = drawCard(); 

    await battle(); 
    updateUI();
}

async function handlePackClick() {
    await openPack();
}

// Initialer Aufruf, wenn die Seite geladen wird
window.onload = updateUI;

// --- ENDE DES JAVASCRIPT CODES ---
</script>
</body>
</html>
